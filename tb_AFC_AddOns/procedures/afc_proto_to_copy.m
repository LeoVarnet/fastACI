% afc_proto - writes protocol file 

%------------------------------------------------------------------------------
% AFC for Mathwork’s MATLAB
%
% Version 1.40.0
%
% Author(s): Stephan Ewert
%
% Copyright (c) 1999-2014, Stephan Ewert. 
% All rights reserved.
%
% This work is licensed under the 
% Creative Commons Attribution-NonCommercial-NoDerivs 4.0 International License (CC BY-NC-ND 4.0). 
% To view a copy of this license, visit
% http://creativecommons.org/licenses/by-nc-nd/4.0/ or send a letter to Creative
% Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.
%------------------------------------------------------------------------------

% Version 1.30.0, last modified 16.04.2013 09:36

function afc_proto

global def
global work

% name of the proticol file
fileName = [def.result_path def.expname '_protocol'];

% current experiment file name
expFileName = work.filename;

% date and time
dateTime = clock;
dateTime = [int2str(dateTime(3)) '-' int2str(dateTime(2)) '-' int2str(dateTime(1)) ' '...
      int2str(dateTime(4)) ':' int2str(dateTime(5)) ':' int2str(fix(dateTime(6)))];
      
% generate new protocol file if not existing
if ~exist([fileName '.pro']);
   header = ['% standard protocol file generated by matlab afc procedure'];
   fid = fopen([fileName '.pro'],'w');
   fprintf(fid,['%s\n'], header);
   fclose(fid);
end

% derive string holding all exppars and their units
parstr = [];
for k = 1:def.expparnum
   eval(['units = def.exppar' num2str(k) 'unit;']);
   parstr = [parstr 'exppar' num2str(k) '[' units ']/'];
end

% string holding expvar and units
varstr = ['expvar[' def.expvarunit ']/'];

% open protocol file to append next entry
fid=fopen([fileName '.pro'],'a');

% in case a custom protocol method is existing, jump there, close the file afterwards and leave afc_proto
if (exist([def.measurementProcedure '_proto']) == 2)
    eval([def.measurementProcedure '_proto']);
  	fclose(fid);
  	return;
end

% write the header for next entry
fprintf(fid,['%s\n'],'%');
if ( strcmp(def.measurementProcedure, 'transformedUpDown') )
	fprintf(fid,['%s\n'],['% new entry (date/experiment/' parstr 'signalpos/response/' varstr 'measurement points/mean+std)']);
elseif ( strcmp(def.measurementProcedure, 'PEST') )
	fprintf(fid,['%s\n'],['% new entry (date/experiment/' parstr 'signalpos/response/' varstr 'end point/procedure)']);
elseif ( strcmp(def.measurementProcedure, 'MML') )
	fprintf(fid,['%s\n'],['% new entry (date/experiment/' parstr 'signalpos/response/' varstr 'estimate points/procedure)']);
elseif ( strcmp(def.measurementProcedure, 'constantStimuli') )
	fprintf(fid,['%s\n'],['% new entry (date/experiment/' parstr 'signalpos/response/' varstr 'measurement points/procedure)']);
else
	% default protocol
	fprintf(fid,['%s\n'],['% new entry (date/experiment/' parstr 'signalpos/response/' varstr 'measurement points/procedure)']);
%elseif ( strcmp(def.measurementProcedure, 'matrixSentenceTest') )
%	fprintf(fid,['%s\n'],['% new entry (date/experiment/' parstr 'sentence/response/' varstr 'percent correct/procedure)']);
end

% write date/time and current experiment file name
fprintf(fid,['%s\n'],dateTime);
fprintf(fid,['%s\n'],expFileName);

% prepare and write the data for each track (just one track if not interleaved)
for i = 1:def.interleavenum

	if ( strcmp(def.measurementProcedure, 'transformedUpDown') )
   		rev = work.expvarrev{i}(end - def.reversalnum+1:end);
		ms{i} = num2str([mean(rev) std(rev,1)],'%8.8f   ');
	elseif ( strcmp(def.measurementProcedure, 'PEST') )
		rev = work.PEST_Expvar{i};
	elseif ( strcmp(def.measurementProcedure, 'MML') )
		rev = work.MML_MuEstimate{i}(end-def.MML_MuStdNum+1:end);
	elseif ( strcmp(def.measurementProcedure, 'constantStimuli') )
		rev = work.expvar{i}(sum(def.practicenum{i}) + 1:end);
	else
		% default
		rev = work.expvar{i};
%  elseif ( strcmp(def.measurementProcedure, 'matrixSentenceTest') )
%		rev = work.answer{i}(1:end);
	end

	expvarrev{i} = num2str(rev,'%8.8f   '); 									% expvarrev at reversals in measurement phase	
	expvar{i} = num2str(work.expvar{i},'%8.8f   ');
	pos{i} = int2str(work.position{i});
	res{i} = int2str(work.answer{i});

    % SE 16.04.2013 15:01 now all in custom procedure	
	switch def.measurementProcedure
        case {'matrixSentenceTest','Intellitest'}
            tmpX = work.OLSA_PresentedWords{i}{1};
            for idx=2:length(work.OLSA_PresentedWords{i})
                tmpX = [tmpX '  ' work.OLSA_PresentedWords{i}{idx}];
            end
            pos{i} = tmpX;  % sentence words
            tmpX = work.OLSA_SelectedWords{i}{1};
            for idx=2:length(work.OLSA_SelectedWords{i})
                tmpX = [tmpX '  ' work.OLSA_SelectedWords{i}{idx}];
            end
            res{i} = tmpX;    % pressed words
	end
	
	%%%%%%%%%%%% start writing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	% write track number if interleaved
	if def.interleaved > 0
		fprintf(fid,['%s\n'],['% track ' num2str(i)]);
	end
	
	% current values for exppar(s)
  for k = 1:def.expparnum
    eval(['expparStr = num2str(work.int_exppar' num2str(k) '{i}, ''%8.8f'' );']);
    fprintf(fid,['%s\n'], expparStr );
  end
	
	% selected data as defined above
  fprintf(fid,['%s\n'],pos{i});
	fprintf(fid,['%s\n'],res{i});
	fprintf(fid,['%s\n'],expvar{i});
	fprintf(fid,['%s\n'],expvarrev{i});
	
	% append name of measurement procedure
   	if ( strcmp(def.measurementProcedure, 'transformedUpDown') )
   		fprintf(fid,['%s\n'],ms{i});
   	elseif ( strcmp(def.measurementProcedure, 'PEST') )
		fprintf(fid,['%s\n'],'PEST');
	elseif ( strcmp(def.measurementProcedure, 'MML') )
		fprintf(fid,['%s\n'],'MML');
   	elseif ( strcmp(def.measurementProcedure, 'constantStimuli') )
		fprintf(fid,['%s\n'],'constantStimuli');
	else
		% default
		fprintf(fid,['%s\n'], def.measurementProcedure );
%    elseif ( strcmp(def.measurementProcedure, 'matrixSentenceTest') )
%		fprintf(fid,['%s\n'],'matrixSentenceTest');
	end
end

% close the protocol file
fclose(fid);

% eof 