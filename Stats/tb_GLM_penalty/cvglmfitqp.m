function [results,evaluation] = cvglmfitqp(y,X,qf,folds,opts)
%[thefit] = cvglmfitqp(y,X,qf,folds,opts)
%
%%% Description:
% Optimises a GLM model through maximum a posteriori probability (MAP) 
% where the internal variable is generated through: r = X*w
%
% Where there is a quadratic penalty on the model parameters:
% p(w) = 1/2*lambda*w'*qf*w
%
% The options are the same as with glmfitqp. folds is a length(y)-by-kfold 
% matrix which specifies how data are distributed across validation folds. 
% It can be generated by getcvfolds.
%
% lambda is optimised by cross-validation. Guesses for lambda are given
% by a trust region second-order polynomial method.
%
%%% Example use:
%
% %Figure out optimal strength of prior through cross validation
% %Assume smoothness of the model parameters
% qf = blkdiag(qfsmooth1D(16),.01);
% rg = (-7.5:7.5)';
% 
% %Simulate a model with w = Gabor function
% w = exp(-rg.^2/3^2).*sin(rg*2*pi/6);
% nobs = 150;
% X = [randn(nobs,length(w)),ones(nobs,1)];
% r = 3*X*[w;.01];
% 
% %output is binary -> logistic regression
% r = binornd(1,1./(1+exp(-r)));
% 
% %Set up 5-fold CV
% folds = getcvfolds(length(r),5,1001);
% 
% %Fit the data
% opts = [];
% opts.family = 'binomlogit';
% opts.lambda0 = 1;
% results = cvglmfitqp(r,X,qf,folds,opts);
% 
% plot(results.w(1:end-1))
%
% It requires: the Parallel Computing toolbox, Optimization toolbox (fminunc)
%
% See also: glmfitqp, getcvfolds
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

defaults.precision          = .05;
defaults.stepsize           = 5;
defaults.minDiffSecondRound = 3;
defaults.maxiter            = 15;
defaults.familyextra        = 1;
defaults.family             = 'binomlogit';
defaults.baseline           = zeros(length(y),1);
defaults.lambda0            = mean(sum(X.^2))*.01; %finds a reasonable range for lambda0
bParallel = 0;
bSerial = ~bParallel;
if bSerial
    defaults.parallel       = 0;
end
if bParallel
    warning('Setting this to parallel temporarily...')
    defaults.parallel = 1;
end

defaults.P0                 = sparse(size(X,2),size(X,2));
defaults.getH               = 0;
defaults.weights            = ones(size(y));
defaults.Display            = 'iter';

opts = setdefaults(opts,defaults);

if opts.parallel 
    try
        % Seems to be the current way to call 'matlabpool' as of R2019:
        p = gcp;
        if p.NumWorkers < 1
            warning('cvglmfitqp:parallel0','matlabpool open must be called beforehand to enable parallel processing on folds');
        end    
    catch me 
        % For older versions of MATLAB:
        if matlabpool('size') < 1 % matlabpool('size')
            warning('cvglmfitqp:parallel0','matlabpool open must be called beforehand to enable parallel processing on folds');
        end
    end
end

if bSerial
    subopts = rmfield(opts,{'stepsize','maxiter','lambda0','parallel','precision','minDiffSecondRound','P0'});
end
if bParallel
    subopts = rmfield(opts,{'stepsize','maxiter','lambda0','precision','minDiffSecondRound','P0'});
end

lambda0 = opts.lambda0;
y_idxs = (1:length(y))';
results = crossValidate(y, y_idxs, lambda0,...
                        @(y,I,oldfit,lambda,a) il_fitAFold(y,I,oldfit,lambda,a,qf,X,opts.P0,subopts),...
                        @(y,I,thefit)          il_evalFold(y,I,thefit,X,subopts),...
                        folds, ...
                        opts);
                    
results.w             = results.finalfit.w;
results.loglikelihood = results.finalfit.loglikelihood;
results.logpenalty    = results.finalfit.logpenalty;
evaluation.eval_fct   = 'evalGlmLikelihood';
evaluation.eval_script_call = results.finalfit.eval_script_call;
evaluation.opts       = results.finalfit.opts;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function thefit = il_fitAFold(y,idx_fit,oldfit,lambda,isfinal,qf,X,P0,glmopts)
% function thefit = il_fitAFold(y,idx_fit,oldfit,lambda,isfinal,qf,X,P0,glmopts)
%
% qf - represents the priors

X = X(idx_fit,:);
glmopts.baseline = glmopts.baseline(idx_fit);
glmopts.weights  = glmopts.weights(idx_fit);
if ~isfinal
    glmopts.Display = 'off';
end

if ~isempty(oldfit)
    glmopts.w0 = oldfit.w;
end

% qf*lambda: Regulariser
thefit = glmfitqp(y,X,P0+qf*lambda,glmopts); % Eq. 3 from Varnet2015

disp('')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [cvll,extrainfo] = il_evalFold(y,idx_validation,thefit,X,glmopts)

cvll = evalGlmLikelihood(y,X(idx_validation,:),thefit.w,glmopts.baseline(idx_validation),glmopts.family,glmopts.familyextra);
extrainfo = [];

disp('')
